/*
 * Copyright 2020 United States Government
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

/*
 * The functions in this file are largely duplicates of what's in the
 * core Maat framework, placed here to allow users to compile and test APBs
 * generated by the OCaml compiler without integrating them in the Maat
 * Framework.
 */

#include <stdio.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <signal.h>
#include <stdarg.h>
#include <stdlib.h>

#define ERROR 0

#define dlog(x, args...) fprintf(stderr, args)

#define INITIAL_BUFFER_SIZE (1 << 20)
#define BUFFER_INCREMENT INITIAL_BUFFER_SIZE
#define MAX_BUFFER_SIZE (1 << 30)

static int maat_read_all(int infd, char **bufout, size_t *szout)
{
    char *buf;
    size_t tmpsize = INITIAL_BUFFER_SIZE;
    buf = malloc(tmpsize);
    if(buf == NULL) {
        return -1;
    }
    size_t offset = 0;
    while(tmpsize < MAX_BUFFER_SIZE) {
        ssize_t nread = read(infd, buf + offset, tmpsize -  offset);
        if(nread == 0) { /* EOF reached */
            *bufout = buf;
            *szout  = offset;
            return 0;
        }
        if(nread < 0) {
            free(buf);
            *bufout = NULL;
            *szout  = 0;
            return -1;
        }
        offset += (size_t)nread;

        if(offset == tmpsize) {
            tmpsize += BUFFER_INCREMENT;
            char *tmp = realloc(buf, tmpsize);
            if(tmp == NULL) {
                goto fail;
            }
            buf = tmp;
        }
    }
    errno = ENOBUFS;

fail:
    free(buf);
    *bufout = NULL;
    *szout = 0;
    return -1;
}

static int maat_write_all(int outfd, char *buf, size_t sz)
{
    size_t total_written = 0;
    while(total_written < sz) {
        ssize_t tmp_written = write(outfd, buf + total_written, sz - total_written);
        if(tmp_written < 0) {
            if(errno != EAGAIN && errno != EWOULDBLOCK) {
                return -1;
            }
        }
        total_written += (size_t)tmp_written;
    }
    return 0;
}

/**
 * The purpose of this function is to fork a child process and for the child to read from infd
 * unil it is no longer able to do so, at which point the child forks off a grandchild which returns
 * while the child writes the data recieved from the parent to a pipe shared by the child and grandchild
 * and then waits until the grandchild dies at which point it exists. If infd is blocking, then this can
 * function as a form of control/data flow - the grandchild will not start execution until the parent is
 * completely finished writing to infd.
 *
 * This method could support sequential forms of ASP execution where one ASP needs to complete and send
 * it's data to the next ASP before it can start execution.
 *
 * In the parent, pidout is the pid of the child process. This is unused in the grandchild. In the grandchild,
 * pipe_read_out is set to the read end of the pipe shared by the child and the grandchild. From this the
 * grancchild can read the output of the parent. In the parent this is set to -1. infd is the file descriptor
 * used to send output from the parent to the grancchild. The remaining arguments are file descriptors that
 * should be closed in the grandchild.
 *
 * The function returns the pid of the child process on success in the parent, 0 in the grand-child, and -1
 * otherwise
 */
int fork_and_buffer(pid_t *pidout, int *pipe_read_out, int infd, ...)
{
    int rc = fork();
    if(rc < 0) {
        dlog(0, "Fork of buffer process failed: %s\n", strerror(errno));
        return -1;
    }

    /*
     * Code block executed only by the parent, records PID of child
     * to give back to the caller
     */
    if(rc > 0) {
        close(infd);
        *pidout = (pid_t) rc;
        *pipe_read_out = -1;
        return rc;
    }

    va_list ap;
    va_start(ap, infd);
    int closeme;
    while((closeme = va_arg(ap, int)) != -1) {
        close(closeme);
    }

    /* From here on out we use exit(-1) to immediately terminate on
     * error rather than `return -1. We don't want the child to
     * attempt ot handle the error and continue execution.
     */

    char *buf;
    size_t sz;
    rc = maat_read_all(infd, &buf, &sz);
    if(rc < 0) {
        dlog(0, "Buffering process failed to read all of input: %s\n", strerror(errno));
        exit(-1);
    }

    int pfds[2];

    rc = pipe(pfds);
    if(rc != 0) {
        dlog(0, "Failed to create pipe for buffer output: %s\n", strerror(errno));
        free(buf);
        exit(-1);
    }

    pid_t pid = fork();

    if (pid < 0) {
        dlog(0, "Fork of buffer output process failed: %s\n", strerror(errno));
        close(pfds[0]);
        close(pfds[1]);
        free(buf);
        exit(-1);
    }

    if(pid == 0) {
        /* we're in the grandchild. we need to return the read end
         * of the pipe so future generations can receive the buffered
         * input from the child.
         *
         * We must also clean up by freeing the buffered input and
         * closing the write end of the pipe.
         */
        *pipe_read_out = pfds[0];
        free(buf);
        close(pfds[1]);
        return 0;
    }

    /* in the child. NB: the calling program isn't expecting this
     * branch to ever return, we must explicitly exit rather than
     * returning. */
    close(pfds[0]);
    rc = maat_write_all(pfds[1], buf, sz);
    if(rc < 0) {
        dlog(0, "Failed to write entire buffer: %s\n", strerror(errno));
        close(pfds[1]);
        free(buf);
        exit(-1);
    }

    /* wait for the grandchild before exiting. */
    waitpid(pid, NULL, 0);

    exit(0);
    /* unreachable return statement to make the compiler happy */
    return 0;
}

int run_asp(pid_t *pidout, int infd, int outfd, char *cmd, ...)
{
    int rc = fork();
    if(rc < 0) {
        dlog(ERROR, "Fork failed: %s\n", strerror(errno));
        return -1;
    } else if(rc > 0) {
        *pidout = (pid_t) rc;
        return 0;
    }

    /* the child */
    va_list args;
    size_t num_reserved_args = 3;   // first three args are reserved
    size_t argc = num_reserved_args;

    va_start(args, cmd);
    while((va_arg(args, char*)) != NULL) {
        argc++;
    }
    int fd;
    while((fd = va_arg(args, int)) != -1) {
        close(fd);
    }
    va_end(args);

    char *argv[argc + 1];
    argv[argc] = NULL;

    size_t MAX_SIZE = 10; // XXX: correct value for this?
    char infd_str[MAX_SIZE];
    char outfd_str[MAX_SIZE];

    rc = snprintf(infd_str, MAX_SIZE, "%i", infd);
    if(rc < 0) {
        dlog(ERROR, "Failed to convert in file descriptor to a string");
        exit(1);
    }

    rc = snprintf(outfd_str, MAX_SIZE, "%i", outfd);
    if(rc < 0) {
        dlog(ERROR, "Failed to convert out file descriptor to a string");
        exit(1);
    }

    /* First three args are reserved */
    int i = 0;
    argv[i++]  = cmd;
    argv[i++]  = infd_str;
    argv[i++]  = outfd_str;

    va_start(args, cmd);
    for(; i < argc; i++) {
        argv[i] = va_arg(args, char*);
    }
    va_end(args);

    if(execv(cmd, argv) < 0) {
        dlog(ERROR, "Failed to exec cmd \"%s\": %s\n", cmd, strerror(errno));
        return -1;
    }
    /* can't get here! */
    return -1;
}
