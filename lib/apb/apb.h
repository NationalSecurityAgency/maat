/*
 * Copyright 2020 United States Government
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
#ifndef __MAAT_APB_APB_H__
#define __MAAT_APB_APB_H__

/*! \file
 * Functionality to support the loading and use of ASP objects.
 * The aspmain process is launched and the ASP
 * object is loaded into its addr space.
 */


#include <common/asp_info.h>
#include <client/maat-client.h>
#include <stdbool.h>

/**
 * Unload the ASP object from the process addr space.  Call the ASP exit function.
 * The ASP object must have been previously
 * loaded with start_asp().
 * Return 0 on success.
 */
int stop_asp(struct asp *asp);

/**
 * Waits for the asp to finish
 */
int wait_asp(struct asp *asp);

/*
 * Spawns a child process which will run the asp specified by the asp struct. The specified infd and
 * outfd will be passed to the command line as a file descriptor to read from and a file descriptor to
 * write to, respectively. to the child as long as they are non-negative, otherwise, they are ignored.
 * If the async flag is true, then the asp will execute asynchronously, and must be waited upon using
 * wait_asp and can be killed using stop_asp. The asp_argv should contain arguments for the ASP and should
 * contain a number of arguments equal to asp_argc. The arguments will be provided to the ASP as:
 *
 * <executable_name> [infd] [outfd] [libcap capabilities, if support is enabled] [arguments in argv]
 *
 * The variadic arguments are used to specify file descriptors that are meant to be closed in the child.
 * Provide all of the file descriptors followed by a -1 to indicate termination of the list. NOTE THAT
 * A -1 IS REQUIRED EVEN IF NO FILE DESCRIPTORS ARE SPECIFIED - the variadic arguments parsing library
 * will not know where to stop parsing otherwise and may close all sorts of random file descriptors.
 *
 * Most APBs assume async is false, but the APBs generated by the Ocaml compiler asssume that they are
 * asynchronous. If run_asp executed with async set to true, invoke wait_asp or stop_asp on asp before
 * using run_asp again, otherwise, the PID of the first invocation of run_asp will be lost.
 */
int run_asp(struct asp *asp, int infd, int outfd, bool async, int asp_argc, char* asp_argv[], ...);

/*
 * This function invokes run_asp but uses a user supplied buffer input source and output destination
 * instead of file descriptors. This is more ergonomic in certain use-cases that utilizing file descriptors.
 * This function returns the following:
 * -5: Error in creating pipes to communicate with the ASP's process
 * -4: Error in running the ASP
 * -3: Error in writing the input buffer to the ASP
 * -2: Error in reading the output buffer from the ASP
 * -1: Error in wating on the ASP
 * 0: Successful execution
 */
int run_asp_buffers(struct asp *asp, const unsigned char *buf_in,
                    size_t buf_in_len, char **out_buf, size_t *buf_out_len,
                    int asp_argc, char *asp_argv[], int timeout, ...);

/**
 * The purpose of this function is to fork a child process and for the child to read from infd
 * unil it is no longer able to do so, at which point the child forks off a grandchild which returns
 * while the child writes the data recieved from the parent to a pipe shared by the child and grandchild
 * and then waits until the grandchild dies at which point it exits. If infd is blocking, then this can
 * function as a form of control/data flow - the grandchild will not start execution until the parent is
 * completely finished writing to infd.
 *
 * This method could support sequential forms of ASP execution where one ASP needs to complete and send
 * it's data to the next ASP before it can start execution.
 *
 * In the parent, pidout is the pid of the child process. This is unused in the grandchild. In the grandchild,
 * pipe_read_out is set to the read end of the pipe shared by the child and the grandchild. From this the
 * grancchild can read the output of the parent. In the parent this is set to -1. infd is the file descriptor
 * used to send output from the parent to the grancchild. The remaining arguments are file descriptors that
 * should be closed in the grandchild.
 *
 * The function returns the pid of the child process on success in the parent, 0 in the grandchild, and -1
 * otherwise
 */
int fork_and_buffer(pid_t *pidout, int *pipe_read_out, int infd, ...);

/*
 * This function asynchronously executes an ASP and executes a fork_and_buffer call where the parent waits
 * on the ASP and the child to terminate execution while the child returns immediately after the fork_and_buffer call
 * with the read end of the pipe stored in the address pointed to by outfd. This can enable you to chain the
 * execution of several ASPs in sequence without personally maintaining the buffering boilerplate. Returns -2
 * on error before the fork, -1 on error in the parent after the fork, 0 for execution in the child, and >0 in the
 * parent, assuming no errors.
 */
int fork_and_buffer_async_asp(struct asp *asp, const int argc, char *argv[], const int infd, int *outfd);

/**
 * This function behaves as the fork_and_buffer_async_asp function except, instead of an input
 * file descriptor, the function takes a buffer and a buffer length as an input. The function
 * creates a pipe and, when the ASP is run, the parent writes the input to the pipe and the
 * ASP reads from this pipe. See fork_and_buffer_async_asp for more details.
 */
int fork_and_buffer_async_asp_buffer(struct asp *asp, const int argc, char *argv[],
                                     const unsigned char *buf_in, size_t buf_in_len,
                                     int timeout, int *outfd);
#endif
