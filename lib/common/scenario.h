/*
 * Copyright 2023 United States Government
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

/*! \file
 * scenario.h: base structure definining an attestation scenario
 */

#ifndef __MAAT_AM_SCENARIO_H__
#define __MAAT_AM_SCENARIO_H__

#include <common/taint.h>
#include <stdlib.h>
#include <unistd.h>
#include <uuid/uuid.h>
#include <string.h>

typedef enum {ROLE_ERR=-1, APPRAISER=0, ATTESTER} role_t;

static char *role_names[] = {
    "appraiser", "attester"
};

typedef enum {ASSOC_ERR=-1, UNDEF_ASSOC=0, CACHE_HIT} association_t;

static inline role_t get_role(const char *str)
{
    if(str == NULL || strlen(str) == 0)
        return ROLE_ERR;

    role_t r;
    for(r=APPRAISER; r<=ATTESTER; r++) {
        if (strcasecmp(str, role_names[r])== 0) {
            return r;
        }
    }

    return ROLE_ERR;
}

typedef enum {
    AM_ERROR = -1,     /* both      */
    IDLE = 0,          /* both      */
    REQUEST_RECEIVED,  /* appraiser */
    INITIAL_SENT,      /* appraiser */
    INITIAL_RECEIVED,  /* attester  */
    MODIFIED_SENT,     /* attester  */
    MODIFIED_RECEIVED, /* appraiser */
    EXECUTE_SENT,      /* appraiser */
    EXECUTE_RECEIVED   /* attester  */
} scenario_state;

static inline char *scenario_state_name(scenario_state s)
{
    static char *state_names[] = {
        "ERROR", "IDLE",
        "REQUEST_RECEIVED",
        "INITIAL_SENT",  "INITIAL_RECEIVED",
        "MODIFIED_SENT", "MODIFIED_RECEIVED",
        "EXECUTE_SENT",  "EXECUTE_RECEIVED"
    };
    return state_names[s + 1];
}

/**
 * Structure describing the entire current state of an
 * attestation. This structure is threaded through the libmaat_apb
 * functions and callbacks. The fields defined here are used by the
 * libmaat_apb code to manage the connection and contract
 * state.
 */
struct scenario {
    char *cacert;		/**
				 * CA certificate file. Set by
				 * application code.
				 */
    char *certfile;		/**
				 * Certificate file. Set by
				 * applicaiton code.
				 */
    char *keyfile;		/**
				 * Private key file. Set by
				 * application code.
				 */
    char *keypass;              /**
                                 * Password for private key
                                 * file. Set by application code.
                                 */
    int sign_tpm;		/**
				 * Sign contract using the tpm or
				 * not. Set by application code.
				 */
    int verify_tpm;		/**
				 * Assume other side used tpm
				 * signatures. Set by application
				 * code.
				 */
    char *tpmpass;                /**
                                 * Password for TPM. Set by
                                 * application code.
                                 */
    char *akctx;                  /**
                                 * AK context file generated by TPM.
                                 */
    char *akpubkey;               /**
                                 * AK public key file generated by TPM.
                                 */
    char *workdir;              /**
				 * Scratch directory for saving
				 * intermediate results. Set by
				 * application code.
				 */
    char *contract;     	/**
				 * Contract to parse. Set by
				 * application code prior to calling
				 * handle_*_contract. Is NULL terminated.
				 */
    size_t size;             	/**
				 * Contract size. Set by application
				 * code prior to calling
				 * handle_*_contract
				 */

    unsigned char *response;    /**
				 * Response contract. Generated by
				 * libmaat handle_*_contract
				 * functions. Should be free()d by
				 * application code. May not be NULL
				 * terminated.
				 */
    size_t respsize;		/**
				 * Response contract size. Generated
				 * by libmaat handle_*_contract
				 * functions.
				 */
    char *nonce;                /**
				 * ASCII/Hex nonce value generated in
				 * handle_base_contract on the
				 * appraiser side, but not used by
				 * the attester path.
				 */
    char *partner_cert;         /**
				 * Generated in
				 * handle_exe_contract. Used by
				 * generate_measurement_contract to
				 * encrypt measurement results.
				 */
    role_t role;		/**
				 * Keep track of what role you are
				 * performing (Attester or Appraiser).
				 */
    unsigned char *info;        /**
				 * Additional info blob used to pass
				 * appraisal parameters from the requestor
				 * to the appraiser. Not generally used by
				 * attesters.
				 */
    size_t info_size;           /**
				 * Size (in bytes) of the info blob.
				 */
    char *place_file;             /**
                                 * Filename of CSV file containing place
                                 * information
                                 */

    scenario_state state;
    GList *current_options;
    int peer_chan;

    char *error_message;

    association_t association;  /**
				 * Identifier for the type of association
				 * with peer
				 */

    /* fields presumed to be appraiser specific */
    char *target_type;
    char *target_fingerprint;
    char *attester_hostname;
    char *attester_tunnel_path;
    unsigned long attester_portnum;
    char *resource;
    int requester_chan;

    /* fields presumed to be attester specific */
    char *partner_fingerprint;

};

static inline int init_scenario(struct scenario *scen,
                                char *cacert, char *certfile,
                                char *keyfile, char *keypass,
                                char *tpmpass, char *akctx,
                                char *akpubkey, int sign_tpm, int verify_tpm,
                                char *place_file, char *contract, size_t contract_size,
                                role_t role)
{
    bzero(scen, sizeof(struct scenario));
    scen->cacert	= cacert;
    scen->certfile	= certfile;
    scen->keyfile	= keyfile;
    scen->keypass       = keypass;
    scen->tpmpass       = tpmpass;
    scen->akctx         = akctx;
    scen->akpubkey      = akpubkey;
    scen->sign_tpm      = sign_tpm;
    scen->verify_tpm    = verify_tpm;
    scen->place_file    = place_file;
    scen->contract	= contract;
    scen->size		= contract_size;
    scen->role		= role;
    scen->association   = UNDEF_ASSOC;
    return 0;
}

/**
 * Frees the struct scenario @scen passed in.
 */
static inline void free_scenario(struct scenario *scen)
{
    if(scen != NULL) {
        /*
          Don't free cacert, certfile, keyfile, keypass, place_file, tpmpass,
          or workdir. These fields are expected to be shared/stack allocated.
          All other fields get free()d.
        */
        free(scen->contract);
        free(scen->response);
        free(scen->nonce);
        free(scen->partner_cert);
        free(scen->info);
        g_free(scen->error_message);

        g_list_free_full(scen->current_options, free);

        if(scen->peer_chan >= 0) {
            close(scen->peer_chan);
        }

        free(scen->target_type);
        free(scen->target_fingerprint);
        free(scen->attester_hostname);
        free(scen->attester_tunnel_path);
        free(scen->resource);

        if(scen->requester_chan >= 0) {
            close(scen->requester_chan);
        }

        free(scen->partner_fingerprint);

        free(scen);
    }
}

#endif
