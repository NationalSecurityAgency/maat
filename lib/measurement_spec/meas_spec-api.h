/*
 * Copyright 2023 United States Government
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
#ifndef __MAAT_MEAS_SPEC_API_H__
#define __MAAT_MEAS_SPEC_API_H__

/*! \file
 *
 */

#include <stdlib.h>
#include <stdint.h>
#include <common/taint.h>
#include <util/util.h>
#include <glib.h>

/**
 * XXX: We use a lot of magic numbers to uniquely identify things like
 * target types.  It's easy enough to use uint32_ts for this to start
 * out with.  We may need to switch to GUIDs in the future.
 */
typedef uint32_t magic_t;
#define MAGIC_MAX (UINT32_MAX-1)
#define INVALID_MAGIC UINT32_MAX
#define MAGIC_FMT "%08x"
#define MAGIC_STR_LEN (sizeof(magic_t)*2)

/**
 * An instance of target_type describes some type of target state that
 * may need to be measured.  This may be a fairly high level type like
 * "file" or a fairly granular type like "inode".
 *
 * A (instance of) target_type combined with an address (below)
 * uniquely defines a particular piece of target state that may need
 * to be measured (presumably it does need to be measured if we're
 * bothering to represent it).  That is, target_type is a meta-type
 * such that a pair (t : target_type, a : address) represents an
 * instance of the type t at address a on the target. The type
 * measurement_variable (below) represents this pair.
 */
struct address;  // forward decl

typedef struct target_type {
    const magic_t magic; /* a magic number for this type */
    const char *name;    /* a vaguely human readable name for this type */

    /* Read an instance of the given type from the given address on
       the target */
    void *(*read_instance)(struct target_type *type, struct address *addr,
                           size_t *size);
} target_type;

/**
 * Base type for addresses.  Different address_spaces will correspond
 * with physical subtypes of address.
 *
 * i.e., we may have
 * struct path_address {
 *     address a;
 *     char abs_path[MAX_PATH_LEN];
 * };
 *
 * To describe files by their absolute paths.
 */
typedef struct address {
    struct address_space *space;
} address;

/**
 * An address_space is basically the type of an address.  Each address
 * space defines access mechanisms for manipulating addresses of the
 * space and getting at data in that space.
 *
 * For example, file_system would be an address_space that understands
 * addresses describing the absolute path to a file.
 */
typedef struct address_space {
    const magic_t magic;
    const char *name;

    /**
       Allocate a new address in this space
    */
    address *(*alloc_address)();

    /**
       Attempt to allocate an address in this space that refers to
       the same object as the given address (possibly from some other
       space).  If the foreign address can't be coerced to this
       space, return NULL
    */
    address *(*coerce_address)(const address *a);

    /**
       Return a copy of an address in this space
    */
    address *(*copy_address)(const address *a);

    /**
       free an address in this space
    */
    void (*free_address)(address *a);

    /**
       Serialize an address in this space as a NULL terminated 7-bit
       ASCII string
    */
    char *(*serialize_address)(const address *a);

    /**
       Parse a NULL terminated 7-bit ASCII string of at most @maxbytes
       (counting the NULL terminator) generated by serialize_address
       into an address in this space.
    */
    address __untainted *(*parse_address)(const char *, size_t maxbytes);

    /**
     * Converts an address in this space to a human readable, NULL
     * terminated 7-bit ASCII string.
     */
    char *(*human_readable)(const address *a);

    /**
     * Parse the human readable 7-bit ASCII representation of an
     * address in this space.
     */
    address *(*from_human_readable)(const char *a);

    /**
       Return true if two addresses are equal.  Both addresses are
       guaranteed to belong to this space
    */
    gboolean (*address_equal)(const address *, const address *);

    /**
       Hash function on addresses in this space
    */
    guint (*address_hash)(const address *);

    /**
       Read raw bytes from the address space starting at the given
       address.
    */
    void *(*read_bytes)(struct address *addr, size_t sz);
} address_space;

/**
   Convenience function to copy an address
*/
static inline address *copy_address(address *addr)
{
    if(!addr->space || !addr->space->copy_address) {
        return NULL;
    }
    return addr->space->copy_address(addr);
}

/**
   Convenience function to create an address in the given space
*/
static inline address *alloc_address(address_space *space)
{
    address *addr = space->alloc_address();
    if(addr)
        addr->space = space;
    return addr;
}

/**
   Convenience function to destroy an address
*/
static inline void free_address(address *addr)
{
    if(addr != NULL && addr->space != NULL)
        addr->space->free_address(addr);
}

/**
    Convenience function to serialize an address
*/
static inline char *serialize_address(const address *addr)
{
    if (addr->space == NULL)
        return NULL;

    return addr->space->serialize_address(addr);
}

/**
    Convenience function to parse an address in the given space
*/
static inline address  __untainted *parse_address(address_space *space, char *s, size_t maxbytes)
{
    return space->parse_address(s, maxbytes);
}

/**
 * Convenience function to get the human readable representation of an address
 */
static inline char *address_human_readable(const address *a)
{
    if (a->space == NULL)
        return NULL;

    return a->space->human_readable(a);
}

/**
 * Convenience function to get an address from its human readable representation
 */
static inline address *address_from_human_readable(address_space *space, char *a)
{
    return space->from_human_readable(a);
}


/**
    Function to compare to addresses for equality. First checks that
    both addresses are in the same space, then calls
    space->address_equals(a1, a2)
*/
static inline gboolean address_equal(const address *a1, const address *a2)
{
    if (a1->space == NULL || a2->space == NULL)
        return FALSE;

    return (a1->space == a2->space) && (a1->space->address_equal(a1, a2));
}

//XXX We are missing a convenience function for coerce
//This function may not exist in the address spaces themselves

/**
 * A measurement_variable is a thing we want to measure.  i.e., a
 * target state component.  As mentioned above, it combines a
 * target_type with an address.
 *
 * Note that it doesn't describe how we want to measure it, only what
 * we want measured.
 */
typedef struct measurement_variable {
    target_type *type;
    address *address;
} measurement_variable;

/**
 * An instance of measurement_type describes how to measure
 * something.
 *
 * This is used both as part of a measurement directive indicating
 * "measure variables of target_type T with measurement type M" and to
 * describe how we actually measured something "I measured variable V
 * with measurement type M".
 *
 * For some target_types we may only have one meaningful
 * measurement_type, but for others (e.g., files) we may have multiple
 * (e.g., hash, fields/lines decomposition).
 */
struct measurement_type;

/**
 * Parent struct (class) of a derived (child) measurement_data.
 * measurement_data should not usually be instantiated itself. Rather,
 * it should be considered a "pure virtual" class, and the derived measurement_data
 * should be instantiated with the correct value of type specified.
 * type is the type of the derived child class.
 */
typedef struct measurement_data {
    struct measurement_type *type;
} measurement_data;

/**
 * The marshalled contents of a measurement_data.
 * unmarshalled_type is the measurement_type of the data that
 * marshalled to create the instance of marshalled_data.
 */
typedef struct marshalled_data {
    measurement_data meas_data;
    magic_t unmarshalled_type;
    size_t  marshalled_data_length;
    char *marshalled_data;
} marshalled_data;

typedef enum {ALL_VALUES, ANY_VALUE} predicate_quantifier;

typedef struct measurement_type {
    const magic_t magic;
    const char *name;
    /**
       Allocate a measurement_data of this measurement_type.
    */
    measurement_data *(*alloc_data)();

    /**
       Copy a measurement_data of this measurement_type
    */
    measurement_data *(*copy_data)(measurement_data *);

    /**
       Free a measurement data of this type
    */
    void (*free_data)(measurement_data *);

    /**
     * Serialize a measurement data of this measurement_type Should
     * assign *@serial_data to point to a malloc()ed region holding
     * the data and *@serial_data_size to the total size of this
     * region (including the NULL terminator).
     *
     * The serialized form of the measurement should be a NULL
     * terminated 7-bit ASCII
     *
     * return 0 on success
     */
    int (*serialize_data)(measurement_data *d, char **serial_data, size_t *serial_data_size);

    /**
     * Unserialize a serialized data str into a measurement_data of the
     * this measurement_type
     * Verifies correct measurement_type
     * sd is the serialized data to unserialize and make into a measurement_data of this type.
     * sd_size is the size in bytes of the serialized data sd.
     * encoded_type is the measurement_type of the data encoded in the serialized data sd
     * d is the created measurement_data.  This memory is caller's responsibility to free.
     * return 0 on success
    */
    int (*unserialize_data)(char *sd, size_t sd_size, measurement_data **d);

    /**
     * Optional method for accessing measurement data as a key-value
     * store. If implemented, on success this function should set
     * *@out to point to a caller-deallocated GList referencing caller
     * deallocated, NULL-terminated strings describing the value(s) of
     * the data @d associatied with the key @feature. This function
     * should return 0 on success.
     *
     * On failure this functions should return < 0 and ensure that
     * *@out is set to NULL.
     */
    int (*get_feature)(measurement_data *d, char *feature, GList **out);

    /**
     * Optional method for checking if measuremnet data satisfies a
     * predicate defined by a quantifier @q (forall or any) an @feature
     * to query (as used in the ->get_feature() call), a comparison
     * operator (such as "equal"), and a @value to compare against.
     *
     * Should return > 0 if the predicate holds, 0 if it doesn't, or <
     * 0 if an error occurrs.
     *
     * If the method sets *@defer to a non-zero value, then the return
     * of the method is ignored and the default implementation is
     * used. This allows types to introduce specialized behaviors
     * and/or operators, but accept the default behavior in some
     * cases.
     *
     * See the documentation for measurement_data_check_predicate()
     * for a description of the default implementation (which may
     * suffice for most types).
     */
    int (*check_predicate)(measurement_data *d,
                           predicate_quantifier q,
                           char *feature, char *operator,
                           char *value, int *defer);

    /**
     * Optional method to return a human readable form of this
     * measurement data. Does not need to be machine parseable or
     * complete. Primarily intended as an aid for debugging.
     *
     * On success, returns 0 and assigns *@out to a malloc()ed buffer
     * containing a NULL-terminated ASCII string of length *@outsize.
     *
     * returns < 0 on failure.
     */
    int (*human_readable)(measurement_data *d,
                          char **out, size_t *outsize);
} measurement_type;

/**
    Wrapper to allocate a measurement data of the given type
*/
static inline measurement_data *alloc_measurement_data(measurement_type *type)
{
    measurement_data *d = type->alloc_data();
    d->type = type;
    return d;
}

/**
    Free a measurement data by calling its type's free function
*/
static inline void free_measurement_data(measurement_data *d)
{
    if(d != NULL)
        d->type->free_data(d);
}

/**
    copy measurement data using the type's copy function
*/
static inline measurement_data *copy_measurement_data(measurement_data *d)
{
    return d->type->copy_data(d);
}

/**
   Convert any measurement data to a marshalled data instance using its serialize method.
   Returns NULL on failure.
*/
marshalled_data *marshall_measurement_data(measurement_data *d);

/**
   Convert a marshalled data back to its original unmarshalled form.
   Returns NULL on failure.
*/
measurement_data *unmarshall_measurement_data(marshalled_data *);

/**
 * Uses the ->get_feature() method of @d's measurement_type to
 * retrieve the value associated with the key @feature from the data
 * @d.
 *
 * On success, returns 0 and sets *@out to point to a (caller
 * deallocated) GList of (caller deallocated) NULL terminated
 * character buffers.
 *
 * Returns < 0 on error.
 */
static inline int measurement_data_get_feature(measurement_data *d, char *feature, GList **out)
{
    if(d->type->get_feature != NULL) {
        return d->type->get_feature(d, feature, out);
    } else {
        dlog(4, "Warning: measurement data type %s does not implement ->get_feature()\n",
             d->type->name == NULL ? "<unknown>" : d->type->name);
    }
    return -1;
}

/**
 * Determine if the given measurement data satisfies a predicate. If
 * the measurement_type of the data @d implements ->check_predicate()
 * method, then that method will be invoked directly on the arguments.
 *
 * If not, default implementation retrieves the value for the
 * @feature using ->get_feature() then comparing it to the @value
 * using a comparison function based on the @operator. The following
 * @operators are understood:
 *
 * Bytewise operators:
 *     "equal"           --> exact equality
 *     "startswith"      --> @value is a prefix of the feature's value
 *     "endswith"        --> @value is a suffix of the feature's value
 *
 * Case insensitive ASCII String operators:
 *     "case-equal"      --> case-insensitive equality
 *     "case-startswith" --> case-insensitive startswith
 *     "case-endswith"   --> case-insensitive endswith
 *
 *     For case insensitive string operators, the feature's value is
 *     assumed to be a NULL terminated ASCII string. Note that the
 *     size of the entire buffer referenced @value, including any NULL
 *     terminator, should be given by @vallen (this is particularly
 *     important for case-startswith and case-endswith which only
 *     match @vallen-1 characters of @value against the feature's
 *     value)
 *
 * Numeric operators:
 *     As signed long values:   "<", "<=", "=", ">=", ">"
 *     As unsigned long values: "u<", "u<=", "u=", "u>=", "u>"
 *
 *     Numeric conversions are performed using strtol/strtoul with a
 *     base argument of 0 meaning the strings are treated as ASCII
 *     numbers in base 10 unless they begin with 0x in which case
 *     hexadecimal is used or just 0 in which case octal is used (see
 *     the strtol(3) for details).
 */
int measurement_data_check_predicate(measurement_data *d, predicate_quantifier q,
                                     char *feature, char *operator,
                                     char *value);

/**
 * Get a human readable form of this measurement data by calling its
 * ->human_readable() .  Primarily intended as an aid for debugging.
 *
 * On success, returns 0 and assigns *@out to a malloc()ed buffer
 * containing a NULL-terminated ASCII string of length *@outsize.
 *
 * returns < 0 on failure. Notable -ENOSYS if the @d's type doesn't
 * implement the method.
 */
static inline int measurement_data_human_readable(measurement_data *d,
        char **out, size_t *outsize)
{
    return d->type->human_readable == NULL ? -ENOSYS :
           d->type->human_readable(d, out, outsize);
}

/**
 * Given two measurement variables, it will check the magic values for
 * target type and uses address_equal on the addresses to determine if
 * they are the same measurement variable
 * Returns 0 on equal, otherwise -1
 */
int compare_measurement_variable(measurement_variable *v1, measurement_variable *v2);

/**
   default functions marshalled data
*/
#define marshalled_data_type_uuid 0xfffffffe; // this is the universally unique 'magic' id number

#define INVALID_MEAS_TYPE ((magic_t)-1);

extern measurement_type marshalled_data_measurement_type;  // this is the measurement_type to use for marshalled_data

/**
   Alloc and initialize a new measurement variable.  Returns NULL on
   failure and sets errno appropriately.
*/
measurement_variable *new_measurement_variable(target_type *type, address *addr);
measurement_variable *copy_measurement_variable(measurement_variable *v);

static inline void free_measurement_variable(measurement_variable *v)
{
    if(v != NULL) {
        free_address(v->address);
        free(v);
    }
}

#endif
