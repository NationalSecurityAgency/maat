/*
 * Copyright 2020 United States Government
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#ifndef __MAAT_AM_CONTRACTS_H__
#define __MAAT_AM_CONTRACTS_H__

/*! \file
 *
 * am/contracts.h: public header file for attestation manager contract
 * handling. Exposes routines for handling request, initial, modified,
 * and execute contracts.
 *
 * The Maat negotiation and attestation protocols assume three parties:
 * (1) a client that requires an integrity evaluation of some target,
 * (2) an appraiser that is able to evaluate integrity evidence on
 * behalf of the client, and (3) an attester capable of collecting
 * evidence regarding the targets integrity. In the negotiation phase,
 * communications between these parties are defined by the libmaat-am
 * and are in the form of XML contract documents. The protocol is
 * roughly as follows:
 *
 *      Client               Appraiser                 Attester
 *         |                     |                        |
 *         |       request       |                        |
 *         |  -----------------> |                        |
 *         |                     |        initial         |
 *         |                     | ---------------------> |
 *         |                     |                        |
 *         |                     |        modified        |
 *         |                     | <--------------------- |
 *         |                     |                        |
 *         |                     |        execute         |
 *         |                     | ---------------------> |
 *         |                     |                        |
 *         |                     |        measurement*    |
 *         |                     | <--------------------- |
 *         |                     |                        |
 *         |       response      |                        |
 *         | <------------------ |                        |
 *         |                     |                        |
 *         |                     |                        |
 *
 * The request message is an XML contract document that may be
 * generated by the create_integrity_request() function of the
 * libmaat-client library. The handle_request_contract() function
 * defined in this library (libmaat-am) processes the request contract
 * to generate the initial contract. The handle_initial_contract() and
 * handle_modified_contract() behave analogously; they process the
 * inidicated contract to generate the subsequent one.
 *
 * The format of the measurement and response contracts is not
 * prescribed by the libmaat-am. After the generating or on receipt of
 * the execute contract the appraiser or attester respectively will
 * spawn an attestation protocol block (APB) (formerly attestation
 * protocol instance or API, beware of legacy documentation)
 * responsible for handling the measurement and response part of the
 * protocol. These APBs may use the libmaat-apb to generate measurement
 * and response XML contract documents in a format similar to the
 * prior contracts, or they may implement their own formats. If the
 * appraiser's APB generates a response contract of the appropriate
 * form, the client may use the parse_integrity_response() function of
 * libmaat-client to extract the appraisal result and attached data.
 */

#include <libxml/parser.h>
#include "am.h"

/**
 * Supported version of the Maat contract format.
 */
#define MAAT_CONTRACT_VERSION "2.0"

/**
 * Type of contract corresponding to negotiation phase.  Note that the
 * AM doesn't know anything about "measurement" or "response"
 * contracts.
 */
typedef enum am_contract_type {
    AM_CONTRACT_REQUEST = 0,
    AM_CONTRACT_INITIAL,
    AM_CONTRACT_MODIFIED,
    AM_CONTRACT_EXECUTE,
    AM_NR_CONTRACT_TYPES
} am_contract_type;


/**
 * String names of contract_type
 */
static const char *am_contract_names[] = {
    "request","initial","modified","execute","measurement"
};

/**
 * Get the name of an am_contract_type. Returns a pointer to the
 * string name of the given contract type (NB: do not free this
 * string!) or NULL if @typ does not represent a valid contract type.
 */
static inline const char *get_contract_name(am_contract_type typ)
{
    if(typ >= AM_CONTRACT_REQUEST && typ < AM_NR_CONTRACT_TYPES) {
        return am_contract_names[typ];
    }
    return NULL;
}

/**
 * Get an am_contract_type enumerated value given its string
 * name. Returns -1 on failure.
 */
static inline am_contract_type get_contract_type(const char *str)
{
    am_contract_type c;

    for (c=AM_CONTRACT_REQUEST; c<AM_NR_CONTRACT_TYPES; c++)
        if (strncasecmp(str, am_contract_names[c],
                        strlen(am_contract_names[c])) == 0)
            return c;

    return -1;
}

/**
 * Get the am_contract_type of @contract (which is @size bytes
 * long). The type should be specified as an attribute of the root
 * <contract> node of the document.
 *
 * On success, the type of contract is stored in *@ctype and 0 is
 * returned.
 *
 * On failure, *@ctype is not modified, and -1 is returned.
 */
int parse_contract_type(char *contract, size_t size, am_contract_type *ctype);

/**
 * Handle the "request" contract sent by a client to an appraiser, and
 * generate an "initial" contract by calling
 * @manager->appraiser_callbacks.get_initial_options().
 *
 * @scen->contract should initially point to the "request" contract to
 * be processed (and @scen->size should be the strlen() of said
 * contract).
 *
 * On success 0 is returned and @scen->response will point to the
 * "initial" contract (of size @scen->respsize) that should be sent to
 * the attester. The caller is responsible for eventually free()ing
 * this memory. Other fields of @scen are not directly modified by
 * this routine (although
 * @manager->appraiser_callbacks.get_initial_options() may choose to
 * modify them).
 *
 * On failure, @scen->response is set to NULL, @scen->respsize is set
 * to 0, and < 0 is returned.
 */
int handle_request_contract(struct attestation_manager *manager,
                            struct scenario *scen);

/**
 * Handle the "initial" contract sent by an appraiser to the attester,
 * and generate a "modified" contract by calling
 * @manager->attester_callbacks.select_options().
 *
 * @scen->contract should initially point to the "initial" contract to
 * be processed (and @scen->size should be the strlen() of said
 * contract).
 *
 * On success 0 is returned and @scen->response will point to the
 * "modified" contract (of size @scen->respsize) that should be sent
 * back to the appraiser. The caller is responsible for eventually
 * free()ing this memory. Other fields of @scen are not directly
 * modified by this routine (although
 * @manager->attester_callbacks.select_options() may choose to modify
 * them).
 *
 * On failure, @scen->response is set to NULL, @scen->respsize is set
 * to 0, and < 0 is returned.
 */
int handle_initial_contract(struct attestation_manager *manager,
                            struct scenario *scen);



/**
 * Handle the "modified" contract sent by an attester back to the
 * appraiser, and generate an "execute" contract by calling
 * @manager->appraiser_callbacks.select_option(), and spawn an
 * attestation protocol block by calling
 * @manager->appraiser_callbacks.spawn_protocol().
 *
 * @scen->contract should initially point to the "modified" contract to
 * be processed (and @scen->size should be the strlen() of said
 * contract).
 *
 * Note that @manager->appraiser_callbacks.spawn_protocol() is called
 * iff generation of the "execute" contract succeeds, but the success
 * or failure of the protocol spawning is not considered in the return
 * value of this function.
 *
 * On success 0 is returned and @scen->response will point to the
 * "execute" contract (of size @scen->respsize) that should be sent
 * back to the appraiser. The caller is responsible for eventually
 * free()ing this memory. Other fields of @scen are not directly
 * modified by this routine (although
 * @manager->appraiser_callbacks.select_option() may choose to modify
 * them).
 *
 * On failure, @scen->response is set to NULL, @scen->respsize is set
 * to 0, no protocol block is spawned, and < 0 is returned.
 */
int handle_modified_contract(struct attestation_manager *manager,
                             struct scenario *scen);


/**
 * Set up pieces that need to be in place before call to
 * handle_execute_contract().  Only used in the case of a cache hit;
 * normal execution sets these up during negotiation.
 *
 * Saves credentials to working directory, adds options in contract
 * to @scen->current_options.
 */
int handle_execute_cache_hit_setup(struct attestation_manager *manager, struct scenario *scen);


/**
 * Handle the "execute" contract sent by an appraiser to an attester
 * by spawning a protocol block by calling
 * @manager->attester_callbacks.spawn_protocol().
 *
 * @scen->contract should initially point to the "execute" contract to
 * be processed (and @scen->size should be the strlen() of said
 * contract).
 *
 * On success 0 is returned, on failure < 0 is returned. No fields of
 * @scen are updated.
 *
 * Note that the success of this routine depends on successfully
 * spawning the protocol block but not on the protocols result. I.e.,
 * this routine will succeed as long as contract validation and
 * @manager->attester_callbacks.spawn_protocol() succeed but the
 * attestation may fail later in the protocol block.
 */
int handle_execute_contract(struct attestation_manager *manager,
                            struct scenario *scen);

/**
 * Creates an integrity contract form the input parameters. The contract is
 * serialized as a null-terminated string into *out with length in *outsize
 * (not counting terminating null). Returns 0 on success or -1 on failure.
 *
 * Params:
 *
 */
int create_error_response(struct scenario *scen);

#endif
